![CI logo](https://codeinstitute.s3.amazonaws.com/fullstack/ci_logo_small.png)

README for project


## Introduction
Rock, Paper, Scissors, Lizard, Spock is a variation on the classic game Rock, Paper, Scissors. In the classic version, each of two players selects one of the three options to "show" their opponent by making a symbol with their fist. A fist for rock, an open hand with fingers together for paper, and two extended fingers (index and middle) for scissors. The winner is determined by the following rules : Scissors cuts paper, paper covers rock, and rock crushes scissors. The problem is that with only three choices, there are a limited number of outcomes and thus many games end up with a tie.

The solution, invented by XXXXX, was to increase the number of options each player has available to them. Thus the introduction of the lizard and Spock (the Science officer from the Star Trek franchise). The rules now are:
Scissors cuts Paper
Paper covers Rock
Rock crushes Lizard
Lizard poisons Spock
Spock smashes Scissors
Scissors decapitates Lizard
Lizard eats Paper
Paper disproves Spock
Spock vaporizes Rock
Rock crushes Scissors

With more options, there is a reduced liklihood of ending with a tie.

In normal gameplay, victory is mostly determined by chance unless the players are somewhow aware of a hidden strategy employed by the opponent. However, for players that know each other, patterns can emerge in gameplay.

The purpose of this project is to create an online game that allows the user to play Rock, Paper, Scissors, Lizard, Spock against the computer using chance and/or skill to win.

For testing, describe process of installing jest and nodemon
### User Stories

As a user I want to:
+ Play the game on a large screen, tablet, or mobile screen.
+ See all of the game elements should fit on one screen. No scrolling should be required to play the game.
+ Have some control the difficulty of the game
+ Use skill to increase my chances of winning the game
+ Have an intutitive and clear layout
+ Know where I stand as the game progresses
+ Have the option to play again or quit
+ Understand the meanings of the images intuitively
+ Understand why I have won or lost a round
+ See the connection to the Big Bang Theory
+ Access the rules of game easily

## UX Design

### Color and Font - Links to the show.
This game was made popular on the popular American TV Series "The Big Bang Theory" when Sheldon introduces the rules to the game. Many players of this game will likely feel some connection to the show and this is reflected in the color scheme and font choices.

The exact font used on the show is a trademark. The Impact font, availbale from Google Fonts, is one that is similar to that used on the show. The color scheme of the show was generated by coolers.io from an image of Sheldon's "Bazinga" shirt. Thus the blue and reddish colors used are based on the show's colors. Both color and iconography are combined in the title where the word "spock" is all capital and in the brick red color. This is in imitation of the shows logo wichh as similar typefacing. The borders and the buttons use the blue and red from the color palette which are similar to the show's. The background color was chosen to be related to but softer than the main colors so that the contrast is sharp enough.

### Landing Page
The landing page is intended to inform the user of the purpose of the site as well as to inform them of the rules of the game.  The landing page consists of the following features:

A hero image with the title of the game along with a call to action to play the game. The image is that of a galaxy in order to evoke a connection to the TV show. The use of the actors' images or any item directly from the show might violate copyright, therefore the image was chosen to obliquely remind people of the Big Bang Theory. The show opens with a picture of the Milky Way and therefore I used an image similar to it. The font, Impact, is also similar to that used on the show.

After a few lines of text, the user can click a button to be directly taken to the game screen. The button color is based on a palette of colors from the show.

Below the hero section are two groups of text that explain the rules of the game as well as how the challenge version of the game works. These blocks are placed below the hero section so the user has the option to look at the rules should they be unfamiliar with the game. If they are familiar, they can just click the button in the hero section and be taken directly to the game screen.

To provide some imagry to enhance the rather large block of text, an image showing the five images of rock, paper, scissors, lizard, spock is shown that encapsulates the rules of the game.

### Use of graphics
The question marks are used to cover the choices of the computer and user. They are colored using the variation of blue and red from the tv show.

The images for the choices were chosen for their soft colors and clarity of meaning. Most users would agree as to their meaning. The only one that might be unclear is the symbol for Spock which is the hand with palm out and fingers parted in two groups of two. This is the vulcan greeting. Although an icon of pop culture, not everyone might grasp the connection to spock. (Although not everyone might undesrstand who or what Spock is.) An image of Mr Spock might run into copyright issues. Therefore the emoji for the vulcan greeting was used. These images are licensed for free use.

### Main Screen
The app has one main screen which contains all of the essential elements of the game. This area is divided into three sections. 

#### Game Information Area
The top section contains a row of elements that are to display the player's choice, then the score board which presents the information on the current score and the current round, and then the area that displays the computer's choice. The coloring is different to create distinction and the color of the score is keyed to the color of player and computer. This was done to save screen real estate. 

#### Choice Images
The second section contains a panel of five images (called "tiles") that represent the choices a player can make. These are placed in a flex display so that they are displayed in a single row on larger screens but wrap on smaller screens.

#### Button Row
The last section contains row of a button to initiate gameplay and a checkbox to indicate if the user wants to play the challenge game.

### Modal Overlays
The user must know not only what the current score is and what round they are on, but also must be provided with feedback as to what the outcome a particular round is, who the winner of the game is, and as to when to make a choice. One could use the alert() JavaScript method to display some information to the user. However, this is not ideal as the alert has generic styling that breaks the theming of the game. One could also employ dialogues from frameworks such as Bootstrap or Materialize. This also is not a good choice as these dialogue boxes are for applications. In commercial video games, dialogue boxes have a "gameified" look. (give example) I wanted to do that here.

The solution is to use a modal overlay. These are elements that cover the screen and prevent the user from interacting with the elements below. They are perfect for displaying information on time of the screen and then either be programmed to disappear automatically after a period of time or when the user dismisses them.

Overlays are simple HTML elements. Their initial display is set to none to make them initially invisible and then they can be programmatically made to appear and disappear as needed. These overalays are styled with CSS like any other HTML elements.

I chose overalys to cover the entire screen with an overlay to prevent interaction. In additon, I styled the elements the overlay (which are just text and some buttons) to have the same font and color scheme as the rest of the game. Overlays are used to announce the winner of a round, the winner of a game, and in the simple game, to prompt the user to make a choice by indivdiually flashing the words "Rock, Paper, Scissors, Lizard, Spock!". At the end of the game, in addition to being notified as to who won, the user is presented with two buttons offering the option to play again or to quit the game.

Modal overlays are also used at the end of a particular round. It is not enough to know simply who one. The user must also know why they won or lost. Thus, a message is displayed next to the notification of a win or loss stating the game rule. For example, if the user selected rock and the computer Spock, then the overlay showing the following would appear: "You lose. Spock vaporizes rock." Or, if the user won, they would be told why. For example f the user chose paper and the computer chose rock, the message: "You won. Paper covers rock." would appear in the overlay.

### Challenge Game
In the analog game, two real players who are playing without strategy are relying on chance to win. The simple version of the computer game is entirely based on chance for a win. The computer picks a tile and the player selects a tile. The player does not see the computer's choice until they themselves have made a choice. Since the computer is not emplying any strategy in a choice, i.e. it is picking at random, then the user's chance of winning is determined randomly. However, the number of outcomes is sifficiently small to ensure the user will win sometimes, but not all time. And conversly, they will lose sometimes, but not all the time. This is key to ensuring a pleasant game experience. However, the game play can be repetative and a bit boring after a while. 

Therefore, I have implemented a challenge version of the game that allows the user to use some skill to increase their chance of winning. In the challenge version of the game, the user is presented with the computer's choice first. They then have a limited amount of time to make their own choice. So that means they must know the rules, perceive the computer's choice, and make the winning selection in time. If they fail to choose in the given time, they automatically lose. To prevent the user from getting too comfortable with the static layout of the image tiles, these are rearranged at the start of the round so the user has to quickly search for the winning tile in a new layout each round.


## Testing
### Development Testing
Throughout the development of the project, testing was performed. As elements were added or a CSS style was applied, the behavior was checked in the Firefox Developer Edition web browser as well as through the developer tools on Google Chrome. A local webserver was launched in python and then tested on these two browser.

#### Deploying a Local Server
To deploy the website locally for debug and design purposes, I opened a terminal and launched a python server by entering:

***
python3 -m http.server
***
A message with the URL of the webserver running on the local machine was then displayed. I copied the link and pasted it into my browser to see the webpages.

#### Development Testing Visual Components
For both the landing page and the game page, responsiveness was tested using the breakpoints in the Chrome browser's developer tools. For example, when I implemented the row of image tiles to serve as the user choices for selecting rock, paper, sciessors, etc, I openened the dev tools in Chrome by clicking on the three dots in the upper right corner, then selecting More Tools, and then selecting developer tools. From there, I would view the page at different breakbponts by clicking on the bars above the page. If I noticed text that was overlapping, or anything offscreen, then I would make a media query in CSS and adjust the layout to fix the issue.

#### Development Testing Javascript
Throughout the development of the project, the JavaScript methods were manually tested by either playing a section of the game and checking behavior or by using the console.log() method to check the state of variables throughout the course of the game in order to isolate bugs in code. Since this was a constant process, the examples are too numerous to list. However, I will give a few examples of how the JavaScript was tested for some key components of the game.

__Shuffling the Tiles__
The shuffling of the tiles was a key feature of the challenge game. In order to do that, all of the children in the <game-tile-element> had to be fetched, copied into an array, and shuffled. The children were fetched using the method:
    ***
function shuffleTiles() {

    let tilePanelArray = document.getElementsByTagName("game-tile-panel");
    let tilePanel = tilePanelArray[0];

    console.log(tilePanel); //Verify I have all of the children of the tile panel.
    let newTileArray = [];

    let tiles = tilePanel.children;
    console.log(tiles); //Verify I have all of the children of the tile panel.
    for (let i = 0; i < tiles.length; i++) {
        newTileArray.push(tiles[i]);

    }
    console.log(newTileArray); //Verify the elements are copied into the new array.
    newTileArray = shuffle(newTileArray);
    console.log(newTileArray); // Verify the elements are shuffled.

    tilePanel.innerHTML = "";

    for (let tile of newTileArray) {
        tilePanel.appendChild(tile);
    }


}
***

The console.log() statements are used to show the states of the variables holding the collection or arrays of elements as the method is executed. For example, I expect to see five elements in newTileArray after the first for loop. Then, after calling the shuffle array method, I should see that they are shuffled by printing them to the console. The final result was checked manually by seeing if the tiles were reshuffled after each round in the challenge game.

__Rounds__
The variables to keep track of the current round was also tracked using console.log().

***
async function launchEasyGameSequence() {
    console.log(currentRound);
    if (currentRound < maxRounds) {
        boardReady = true;
        currentRound++;
        console.log(currentRound);
        document.getElementById("round-value").innerText = currentRound;
        resetImages();
        showStartRoundDialogue();

    } else {

        let winner = determineGameWinner();
        alertWinner(winner);
        boardReady = false;
    }
}

***
In this example, currentRound value was checked before the if statement to ensure that the correct value was being compared and then after the increment operation to ensure it would be incremented. I expected to see the values incremented in both log statements which is what occurred.
#### Unit Testing Javascript

### High Level Testing
High level testing was performed. The accuracy of navigation was tested for proper functionality. Website layout responsiveness was tested on the Chrome, Firefox, Opera, and Safari web browsers running on laptops. The website was also tested on a real Android device (Motorola G6+). In addtion to testing layout responsiveness, the gameplay was tested. The testing performed can be found in the following document whose size prevents clear reading here.



### Validator Testing
All Pages were run through the [W3C HTML Validator](https://validator.w3.org/) and showed no errors.  
CSS Stylesheet was run through the [W3C CSS Validator](https://jigsaw.w3.org/css-validator/validator) and showed no errors.  

## Version Control Strategy
Git was employed in this project and the project code hosted on [GitHub](https://github.com/). I used branches in order to keep the main branch as "pure" as possible. The strategy was to have each branch dedicated to one feature or fix. For example, coding the landing page or coding the structure page. I did not always stick to this strategy. There is a branch called re-design that has far too many commits. Ideally, these would be broken down further so that each branch is self explanatory as to what it is responsble for. Once I was satisfied at a particular stage of a branch, I would navigate to GitHub, click on my repository, select the branch, and create a pull request. GitHub would then check if there are no conflicts and indicate if the branch could be merged into main. (One can choose which branch to merge into.) Once the pull request is created, I navigated down, wrote a comment, and clicked on the green Merge button and the commits would be merged into the main branch.

I tried to keep commits as atomic as possible - focusing only one one element or feature at a time. This was not always the case, but most of the commits are realtively small changes.

### VCS in Visual Studio Code
To make a commit, I clicked on the branch icon in the sidebar of the ide. There, one could see all the files that had changed since the last commit. To stage commits, I clicked on the plus icon next to the file that I wanted to stage. If I thought changes in different files should be commited together, I added multiple files. Occasionaly, after adding a bug or a breaking change, I would discard my changes by clicking in the left curly arrow icon. I then added a commit message in the textfield at the top of the sidebar which was as descriptive and brief as possible. I then clickd on the Commit button. To push, I clicked on the three dot icon and selected push.


## Deployment

### Project Creation
* The project was started by navigating to the [template] and clicking 'Use this template'. Under Repository name I input ci-project-2. I then navigated to the new [repository](https://github.com/tony-albanese/ci-project-2). 

TODO: Import into VS Code Desktop

### Using Github Pages
1. Navigate to the GitHub [Repository:](https://github.com/tony-albanese/ci-project-2)
1. Click the 'Settings' Tab.
1. Scroll Down to the Git Hub Pages on the left panel.
1. Select Deploy from a Branch
1. Select 'main' as the source.
1. Click the Save button.
1. Click on the link to go to the live deployed page.


## Features left to implement

## Credits
- The images were take from flaticon.com and are used with permission.
- I used a switch block and case statements to determine the winner of each round. The switch was based on a unique string made from the user and computer tile choices. The inspiration for this method came from the YouTuber Ania Kubow on her Channel "Code with Ania Kubow" in which she shows how to code a rock paper scissors game. LINK TO VIDEO
- Most programming languages have a built in methods for shuffling the contents of an array. JavaScript does not. The method I used to shuffle the contents of the tile card array was taken from stackoverflow and can be found here:
- The initial styling for the overlay came from W3Schools. I took the CSS they used and just tweaked a few things for my own design.
- initial styling for the slider came from w3 schools